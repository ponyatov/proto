## @file
## @brief prototype knowledge database implementation /stage 1/

import os
# need for sys.argv command line parameters and support file naming
import sys
# constant detection
import re


## @defgroup stage1 Stage 1
## @brief Autogenerated @ref stage1 in S1.py
## @{


## @defgroup sym Symbolic class system
## @brief <a href="http://ponyatov.quora.com/On-computer-language-design-Symbolic-data-type-system">Generic types class system (metaprogramming and symbolic computations)</a>
## @{


## @defgroup qbject Qbject
## @brief base class provides universal objects can hold any nested elements
 
## base Qbject class, such named for avoiding Python3 interference with `Object`
## @ingroup qbject
class Qbject:
    ## construct with given value as `<type:value>` pair 
    def __init__(self, V, token=None, doc=''):
        ## <type:value> must be compatible with PLY library token objects
        self.type = self.__class__.__name__.lower()
        ## single value
        self.value = V
        ## `attr{}`ibutes /associative array, unordered/
        self.attr = {}
        ## `nest[]`ed elements /ordered vector/
        self.nest = []
        ## docstring
        if doc: self['doc'] = String(doc)
        ## `immediate` flag for objects executes in compile mode
        self.immed = False
        # process lexeme data for lexer
        if token:
            ## lexeme length as it written in source code
            self.lexlen = len(token.value)
            ## lexeme char position in source code
            self.lexpos = token.lexpos - self.lexlen
            ## lexeme line number in source code
            self.lineno = token.lineno
    ## by default all objects `execute`s in itself
    def __call__(self): D << self ; return self

    ## `object[key]` operator: **lookup** in `attr{}`ibutes
    def __getitem__(self,key): return self.attr[key]
    ## `container[key]=object` operator: **store to object** by attribute key 
    def __setitem__(self,key,o): self.attr[key] = o ; return self

    ## `<<` operator for stack-like default behavior
    def __lshift__(self,o): return self.push(o)
    ## append element
    def push(self,o): self.nest.append(o) ; return self
    ## @returns top element /without removing/
    def top(self): return self.nest[-1]
    ## @returns top element
    def pop(self): return self.nest.pop()
    ## drop top element
    def drop(self): del self.nest[-1] ; return self
     
        
    ## `print object` operator
    def __repr__(self): return self.dump()
    ## full dump in tree form
    ## @returns string 
    def dump(self,depth=0,prefix=''):
        S = self.pad(depth) + self.head(prefix)
        for i in self.attr:
            S += self.attr[i].dump(depth+1,prefix='%s = '%i)
        return S
    ## left pad for treee output
    ## @returns string `'\\n\\t...'`
    def pad(self,N): return '\n' + '\t'*N
    ## short header-only dump
    ## @returns string `<type:value>` 
    def head(self,prefix=''): return '%s<%s:%s>' % (prefix,self.type,self.str())
    ## value in string representation
    def str(self): return self.value
    


## @defgroup prim Primitive
## @brief Core machine-level types
## @{

## primitive machine-level types
class Primitive(Qbject): pass

## symbol/atom
class Symbol(Primitive): pass

## string 
class String(Primitive):
    ## linear `string` representation with escapes
    def str(self):
        S = '\''
        for c in self.value:
            if c == '\n': S += '\\n'
            elif c == '\t': S += '\\t'
            else: S += c
        return S + '\''

## number
class Number(Primitive): pass

## integer number
class Integer(Number): pass

## @}


## @defgroup container Container
## @brief objects targeted for data holding
## @{

class Container(Qbject): pass

class Stack(Container): pass

class Map(Container): pass

## @}


## @defgroup s1active Active
## @brief objects with executable semantics
## @{

class Active(Qbject): pass

class Function(Active): pass

class Operator(Active): pass

class DefOperator(Operator): pass

## @}


## @defgroup s1meta Meta
## @brief metaprogramming
## @{

class Meta(Qbject): pass

class Comment(Meta): pass

## @}


## @defgroup io IO
## @brief Filesystem and Network interfacing 
## @{

## @}


## @}


## @defgroup fvm oFORTH Virtual Machine
## @brief FORTH-inspired stack engine based on OOP /no addressable memory/
## @{

## data stack
D = Stack('DATA')

## vocabulary
W = Map('FORTH')


## @defgroup s1lexer Syntax parser
## @brief powered with
## <a href="http://ponyatov.quora.com/Text-data-formats-Parsing-with-Python-and-PLY-library">PLY library</a>
## `(c) David M Beazley` 
## @{

import ply.lex  as lex
import ply.yacc as yacc

## @}

## @}

## @defgroup metainfo Metainformation
## @brief Project info
## @{

## short module name
MODULE  = 'proto'
## short info about module (oneliner)
TITLE   = 'prototype knowledge database implementation'
## contact emain
EMAIL   = 'dponyatov@gmail.com'
## author
AUTHOR  = 'Dmitry Ponyatov'
## licence info
LICENCE = 'All rights reserved'
## github repository location
GITHUB  = 'https://github.com/ponyatov/proto'
## manual
MANUAL  = 'Quora blog: http://www.quora.com/profile/Dmitry-Ponyatov/all_posts'
## license
LICENSE = 'All rights reserved'
 
## longer project about
ABOUT  = '''
'''

## autogenerated README.md
README = '''
# %s
## %s
### ask for lessons how to reimplement it to know deep in use
 
(c) %s <<%s>>, %s

%s
 
github: %s
 
%s
''' % (MODULE, TITLE, AUTHOR, EMAIL, LICENSE, ABOUT, GITHUB, ABOUT)

W['MODULE']  = String(MODULE)
W['TITLE']   = String(TITLE)
W['AUTHOR']  = String(AUTHOR)
W['LICENCE'] = String(LICENCE)
W['GITHUB']  = String(GITHUB)
W['MANUAL']  = String(MANUAL)
W['ABOUT']   = String(ABOUT)

W['STAGE']   = Number(re.findall(r'S(\d)\.py$',sys.argv[0])[0])

## @}

## @}


print W
