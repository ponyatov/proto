## @file
## @brief prototype knowledge database implementation /stage 1/

## @defgroup stage1 Stage 1
## @brief Autogenerated @ref stage1 in S1.py
## @{

import os,sys,re

## @defgroup s1sym Symbolic class system
## @{

## base object class, such named for avoiding Python3 interference with `Object`
class Qbject:
    ## construct as `<type:value>` pair 
    ## **universal object can hold nested elements**
    def __init__(self,V,token=None):
        ## object type
        self.type = self.__class__.__name__.lower()
        ## single value
        self.value = V
        ## `attr{}`ibutes /associative array/
        self.attr = {}
        ## init `nest[]`ed elements /ordered vector/
        self.nest = []
        ## lexer info
        if token:
            ## lexeme length
            self.lexlen = len(token.value)
            ## lexer position
            self.lexpos = token.lexpos - self.lexlen
        
    ## `print object` operator
    def __repr__(self): return self.dump()
    ## full dump in tree form
    ## @returns string 
    def dump(self,depth=0,prefix=''):
        S = self.pad(depth) + self.head(prefix)
        for i in self.attr:
            S += self.attr[i].dump(depth+1,prefix='%s = '%i)
        return S
    ## left pad for treee output
    ## @returns string `'\\n\\t...'`
    def pad(self,N): return '\n' + '\t'*N
    ## short header-only dump
    ## @returns string `<type:value>` 
    def head(self,prefix=''): return '%s<%s:%s>' % (prefix,self.type,self.str())
    ## value in string representation
    def str(self): return self.value
    ## `container[key]=object` operator: **store to object** by attribute key 
    def __setitem__(self,key,o): self.attr[key] = o ; return self
    ## `object[key]` operator: **lookup** in `attr{}`ibutes
    def __getitem__(self,key): return self.attr[key]

## @defgroup s1prim Primitive
## @brief primitive machine-level types
## @{

## primitive machine-level types
class Primitive(Qbject): pass

## symbol/atom
class Symbol(Primitive): pass

## string 
class String(Primitive):
    ## linear `string` representation with escapes
    def str(self):
        S = '\''
        for c in self.value:
            if c == '\n': S += '\\n'
            elif c == '\t': S += '\\t'
            else: S += c
        return S + '\''

## number
class Number(Primitive): pass

## integer number
class Integer(Number): pass

## @}

## @defgroup s1container Container
## @brief objects targeted for data holding
## @{

class Container(Qbject): pass

class Stack(Container): pass

class Map(Container): pass

## @}

## @defgroup s1active Active
## @brief objects with executable semantics
## @{

class Active(Qbject): pass

class Function(Active): pass

class Operator(Active): pass

class DefOperator(Operator): pass

## @}

## @defgroup s1meta Meta
## @{

class Meta(Qbject): pass

class Comment(Meta): pass

## @}

## @defgroup io IO
## @brief Filesystem and Network interfacing 
## @{

## @}

## @}

## @defgroup s1lexer Syntax parser
## @brief powered with
## <a href="http://ponyatov.quora.com/Text-data-formats-Parsing-with-Python-and-PLY-library">PLY library</a>
## `(c) David M Beazley` 
## @{

import ply.lex  as lex
import ply.yacc as yacc

## @brief token types binded with @ref Qbject
## @details Every Qbject type can be matched by regexp in string form
## will be used as token by PLY library. To do it all Qbjects was done 
## compatible with PLY requirements for token: 
## they must contain predefined set of fields @see PLY manual.
##
## every token type must be equal to lowercased 
## name of correspondent Qbject class

tokens = ['comment','symbol','number','num','exp','int','hex','bin',
          'operator','defoperator','string','const']

## lexer states: extra `string` mode
states = (('string','exclusive'),)

## don't ignore anything in string
t_string_ignore = ''

## string lexer rule: start `string` mode 
def t_string(t):
    r'\''
    t.lexer.push_state('string')
    t.lexer.lexstring = ''
    t.lexer.posstring = t.lexer.lexpos
## string lexer rule: stop `string` mode 
def t_string_string(t):
    r'\''
    t.lexer.pop_state()
    t.value  = t.lexer.lexstring
    t.lexpos = t.lexer.posstring + len(t.value)
    return String(t.value,token=t)
## any character
def t_string_char(t):
    r'.'
    t.lexer.lexstring += t.value

## drop spaces
t_ignore = ' \t\r\n'

## lexer error callback
def t_ANY_error(t): raise SyntaxError(t)

## comment lexer rule
def t_comment(t):
    r'[\\\#].*\n|\(.*?\)'
    t.lexpos = t.lexer.lexpos
    return Comment(t.value.replace('\n',''),token=t)

## hex number
def t_hex(t):
    r'0x[0-9a-fA-f]+'
    t.lexpos = t.lexer.lexpos
    return Number(t.value,token=t)

## binary number
def t_bin(t):
    r'0b[01]+'
    t.lexpos = t.lexer.lexpos
    return Number(t.value,token=t)

## number
def t_number(t):
    r'[\+\-]?[0-9]+\.[0-9]*([eE][\+\-]?[0-9]+)?'
    t.lexpos = t.lexer.lexpos
    return Number(t.value,token=t)

## exponential number variant
def t_exp(t):
    r'[\+\-]?[0-9]+([eE][\+\-]?[0-9]+)?'
    t.lexpos = t.lexer.lexpos
    return Number(t.value,token=t)

## integer
def t_int(t):
    r'[\+\-]?[0-9]+'
    t.lexpos = t.lexer.lexpos
    return Number(t.value,token=t)

## definition operator
def t_defoperator(t):
    r'[\:\;]'
    t.lexpos = t.lexer.lexpos
    return DefOperator(t.value,token=t)

## operator
def t_operator(t):
    r'[\<\>\+\-\*\/\=\@\!]'
    t.lexpos = t.lexer.lexpos
    return Operator(t.value,token=t)

## symbol: word name
def t_symbol(t):
    r'[a-zA-Z0-9_]+'
    t.lexpos = t.lexer.lexpos
    return Symbol(t.value,token=t)

## lexer
lexer = lex.lex()

## @}

## @defgroup s1fvm oFORTH Virtual Machine
## @brief FORTH-inspired stack engine based on OOP /no addressable memory/
## @{

## data stack
D = Stack('DATA')

## vocabulary
W = Map('FORTH')

## @defgroup s1fqueue Interpreter Queue
## @brief Interface between oFORTH and GUI/network query services
## @{
import Queue,threading

## @}

## @}

## @defgroup s2meta Metainfo
## @brief metaprogramming
## @{

## short module name
MODULE  = 'proto'
## short info about module (oneliner)
TITLE   = 'prototype knowledge database implementation'
## author
AUTHOR  = 'Dmitry Ponyatov <<dponyatov@gmail.com>>'
## licence info
LICENCE = 'All rights reserved'
## github repo
GITHUB  = 'https://github.com/ponyatov/proto'
## manual
MANUAL  = 'Quora blog: http://www.quora.com/profile/Dmitry-Ponyatov/all_posts'
## autogenerated ABOUT
ABOUT  = '''
# %s
### %s

(c) %s %s

github: %s
manual: %s
'''%(MODULE,TITLE,AUTHOR,LICENCE,GITHUB,MANUAL)

W['MODULE']  = String(MODULE)
W['TITLE']   = String(TITLE)
W['AUTHOR']  = String(AUTHOR)
W['LICENCE'] = String(LICENCE)
W['GITHUB']  = String(GITHUB)
W['MANUAL']  = String(MANUAL)
W['ABOUT']   = String(ABOUT)

W['STAGE']   = Number(re.findall(r'S(\d)\.py$',sys.argv[0])[0])

## @} 

## @defgroup s1gui GUI
## @brief light set of GUI view/controllers and micro/IDE
## @{

import wx, wx.stc

## GUI element
class GUI(Qbject): pass

## window
class Frame(GUI):
    ## construct window
    def __init__(self,V):
        GUI.__init__(self, V)
        ## wrapped wxframe
        self.frame = wx.Frame(None,title=V)
    ## close window event forwarder
    def Close(self): self.frame.Close()

## menu        
class Menu(GUI):
    ## construct menu
    ## @param[in] frame owner frame  
    def __init__(self,frame):
        GUI.__init__(self, frame.value)
        ## menubar
        self.menubar = wx.MenuBar() ; frame.frame.SetMenuBar(self.menubar)
        ## file menu
        self.file = wx.Menu() ; self.menubar.Append(self.file,'&File')
        ## file/save
        self.save = self.file.Append(wx.ID_SAVE,'&Save')
        ## file/backup (vocabulary)
        self.backup = self.file.Append(wx.ID_APPLY,'&Backup\tCtrl+E')
        ## file/quit
        self.quit = self.file.Append(wx.ID_EXIT,'&Quit')
        ## debug menu
        self.debug = wx.Menu() ; self.menubar.Append(self.debug,'&Debug')
        ## debug/update
        self.update = self.debug.Append(wx.ID_REFRESH,'&Update\tF12')
        ## debug/vocabulary dump window toggle
        self.voc = self.debug.Append(wx.ID_ANY,'&Vocabulary\tF8',kind=wx.ITEM_CHECK)
        ## debug/stack dump window toggle
        self.stack = self.debug.Append(wx.ID_ANY,'&Stack\tF9',kind=wx.ITEM_CHECK)
        ## help menu
        self.help = wx.Menu() ; self.menubar.Append(self.help,'&Help')
        ## help/about
        self.about = self.help.Append(wx.ID_ABOUT,'&About\tF1')
        
## editor widget (Scintilla wrapper)
class Editor(GUI):
    ## @param[in] V file name
    ## @param[in] frame parent Frame instance
    def __init__(self,V,frame):
        GUI.__init__(self, V)
        self['frame'] = Frame(V)
        ## wx.stc.StyledEditor wrapper (Scintilla)
        self.editor = wx.stc.StyledTextCtrl(frame.frame)
        ## set default styling in editor
        self.editor.SetTabWidth(4)
        self.editor.StyleSetSpec(wx.stc.STC_STYLE_DEFAULT,
                'face:%s,size:%s' % (font.FaceName, font.PointSize))
        ## colorizer
        self.initColorizer()
    ## init colorizer
    def initColorizer(self):
        ## comment style
        self.style_COMMENT = 1
        self.editor.StyleSetSpec(self.style_COMMENT,'fore:grey')
        ## number style
        self.style_NUMBER = 2
        self.editor.StyleSetSpec(self.style_NUMBER,'fore:darkgreen')
        ## defoperator
        self.style_DEFOP = 3
        self.editor.StyleSetSpec(self.style_DEFOP,'fore:red')
        ## operator
        self.style_OP = 4
        self.editor.StyleSetSpec(self.style_OP,'fore:darkcyan')
        ## string literal
        self.style_STRING = 5
        self.editor.StyleSetSpec(self.style_STRING,'fore:darkblue')
        ## constant literal
        self.style_CONST = 6
        self.editor.StyleSetSpec(self.style_CONST,'fore:brown')
        # bind colorizer event
        self.editor.Bind(wx.stc.EVT_STC_STYLENEEDED,self.onStyle)
    ## colorizer styling event callback
    def onStyle(self,e):
        lexer.input(self.editor.GetValue())
        while True:
            token = lexer.token()
            if not token: break                             # end of source
            self.editor.StartStyling(token.lexpos, 0xFF)
            if token.type == 'comment':
                self.editor.SetStyling(token.lexlen,self.style_COMMENT)
            elif token.type == 'number':
                self.editor.SetStyling(token.lexlen,self.style_NUMBER)
            elif token.type == 'string':
                self.editor.SetStyling(token.lexlen,self.style_STRING)
            elif token.type == 'operator':
                self.editor.SetStyling(token.lexlen,self.style_OP)
            elif token.type == 'defoperator':
                self.editor.SetStyling(token.lexlen,self.style_DEFOP)
            elif token.type == 'symbol' and re.match(r'[A-Z]+',token.value):
                self.editor.SetStyling(token.lexlen,self.style_CONST)
            else:
                self.editor.SetStyling(0,0)
    ## set text contents value
    def SetValue(self,value): self.editor.SetValue(value)
    ## get text value from wrapped wx.stc
    def GetValue(self): return self.editor.GetValue()
        
## IDE window (base GUI widget in micro IDE)
class IDE(GUI):
    ## construct editor
    ## @param[in] V with given file name (and title)
    def __init__(self,V):
        GUI.__init__(self, V)
        frame = self['frame'] = Frame(V)
        menu = self['menu'] = Menu(frame)
        ## styled editor
        self['editor'] = Editor(V,frame)
        self.onLoad()
        ## menu/key bindings
        frame.frame.Bind(wx.EVT_MENU,self.onSave,menu.save)
        frame.frame.Bind(wx.EVT_MENU,self.onClose,menu.quit)
        frame.frame.Bind(wx.EVT_MENU,self.onSave,menu.save)
        frame.frame.Bind(wx.EVT_MENU,self.onVoc,menu.voc)
        frame.frame.Bind(wx.EVT_MENU,self.onStack,menu.stack)
        frame.frame.Bind(wx.EVT_MENU,self.onUpdate,menu.update)
        frame.frame.Bind(wx.EVT_MENU,lambda e:wx.MessageBox(ABOUT),menu.about)
    ## show frame forwarder        
    def Show(self): self['frame'].frame.Show()
    ## editor visible
    def isVisible(self): return self['frame'].frame.IsShown()
    ## update callback [F12]
    def onUpdate(self,event):
        if   wxVoc.isVisible():   wxVoc['editor'].editor.SetValue(W.dump())
        if wxStack.isVisible(): wxStack['editor'].editor.SetValue(D.dump())
    ## vocabulary window update callback
    def onVoc(self,event):
        F = wxVoc['frame'].frame
        if F.IsShown(): F.Hide()
        else:           F.Show() ; self.onUpdate(event)
    ## stack window update callback
    def onStack(self,event):
        F = wxStack['frame'].frame
        if F.IsShown(): F.Hide()
        else:           F.Show() ; self.onUpdate(event)
    ## close editor
    def Close(self): self['frame'].frame.Close()
    ## event on editor exit
    def onClose(self,event):
        wxMain['frame'].Close()
        wxVoc['frame'].Close() ; wxStack['frame'].Close()
        sys.exit(0)
    ## save file
    def onSave(self,event):
        F = open(self.value,'w')
        F.write(self['editor'].GetValue())
        F.close()
    ## event on editor start (load file from window title)
    def onLoad(self):
        try: F = open(self.value,'r')
        except IOError: return
        self['editor'].SetValue(F.read()) ; F.close()
    ## event on save callback
    def onSave(self,event):
        F = open(self.value,'w') ; F.write(self['editor'].GetValue()) ; F.close()

## @}

## @}

## wxPython application
wxapp = wx.App()

# large monospace font adopted for screen size
## fetch screen height as base for font scale
displaY = wx.GetDisplaySizeMM()[1]
## fetch available font from system
font = wx.Font(displaY / 0x10,
               wx.FONTFAMILY_MODERN, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_BOLD)

## uIDE vocabulary dump
wxVoc   = IDE(sys.argv[0]+'.words')
## uIDE stack dump
wxStack = IDE(sys.argv[0]+'.stack')
## uIDE workpad editor
wxMain  = IDE(sys.argv[0]+'.src') ; wxMain.Show()

wxapp.MainLoop()
