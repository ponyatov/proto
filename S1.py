## @file
## @brief prototype knowledge database implementation /stage 1/

import os
# need for sys.argv command line parameters and support file naming
import sys
# constant detection
import re


## @defgroup stage1 Stage 1
## @brief Autogenerated @ref stage1 in S1.py
## @{


## @defgroup sym Symbolic class system
## @brief <a href="http://ponyatov.quora.com/On-computer-language-design-Symbolic-data-type-system">Generic types class system (metaprogramming and symbolic computations)</a>
## @{


## @defgroup qbject Qbject
## @brief base class provides universal objects can hold any nested elements
 
## base Qbject class, such named for avoiding Python3 interference with `Object`
## @ingroup qbject
class Qbject:
    ## construct with given value as `<type:value>` pair 
    def __init__(self, V, token=None, doc=''):
        ## <type:value> must be compatible with PLY library token objects
        self.type = self.__class__.__name__.lower()
        ## single value
        self.value = V
        ## `attr{}`ibutes /associative array, unordered/
        self.attr = {}
        ## `nest[]`ed elements /ordered vector/
        self.nest = []
        ## docstring
        if doc: self['doc'] = String(doc)
        ## `immediate` flag for objects executes in compile mode
        self.immed = False
        # process lexeme data for lexer
        if token:
            ## lexeme length as it written in source code
            self.lexlen = len(token.value)
            ## lexeme char position in source code
            self.lexpos = token.lexpos - self.lexlen
            ## lexeme line number in source code
            self.lineno = token.lineno
            
    ## by default all objects `execute`s in itself
    def __call__(self): D << self ; return self
    
    ## @name attributes and object slots
    ## @{

    ## `object[key]` operator: **lookup** in `attr{}`ibutes
    def __getitem__(self,key): return self.attr[key]
    
    ## `container[key]=object` operator: **store to object** by attribute key 
    def __setitem__(self,key,o): self.attr[key] = o ; return self
    
    ## @}
    
    ## @name stack/vector behaviour
    ## @{

    ## `<<` operator for stack-like default behavior
    def __lshift__(self,o): return self.push(o)
    
    ## append element
    def push(self,o): self.nest.append(o) ; return self
    
    ## @returns top element /without removing/
    def top(self): return self.nest[-1]
   
    ## @returns top element
    def pop(self): return self.nest.pop()
    
    ## drop top element
    def drop(self): del self.nest[-1] ; return self
    
    ## @}
     
    ## @name dump
    ## @{
    
    ## `print object` operator
    ## @returns string full text dump in tree form
    def __repr__(self): return self.dump()
    
    ## variable holds IDs of all dumped objects (to avoid infty recursion)
    dumped = {} 
   
    ## dump any object in full tree form (with infty recursion blocked)
    ## @returns string full text dump in tree form
    def dump(self, depth=0, prefix=''):
        # generate short header
        S = self.pad(depth) + self.head(prefix)
        # avoid infty recursion
        if not depth: self.dumped.clear()           # reset dumped registry
        else:
            if self in self.dumped: return S+'...'  # break dumps
            else:                   self.dumped[self] = 0
        # attributes
        for i in self.attr: S += self.attr[i].dump(depth+1, prefix='%s = ' % i)
        # nest[]ed elements
        for j in self.nest: S += j.dump(depth+1)
        # return resulting tree
        return S
    
    ## left padding for treee output
    ## @returns string `'\\n\\t...'`
    def pad(self,N): return '\n' + '\t' * N
    
    ## value in string representation *to be overrided*
    ## (can be differ from @ref value for complex objects)
    def str(self): return self.value
    
    ## dump object in short form (header only)
    ## @returns string `<type:value>` 
    def head(self,prefix=''):
        I = ' immed' if self.immed else ''
        return '%s<%s:%s> 0x%X %s' % (prefix, self.type, self.str(), id(self), I)

    ## @}

## @defgroup prim Primitive
## @brief primitive computer types (evaluates to itself)
## @{

## primitive machine-level types
class Primitive(Qbject): pass

## symbol/atom
class Symbol(Primitive): pass

## string 
class String(Primitive):
    ## linear `string` representation with escapes
    def str(self):
        S = '\''
        for c in self.value:
            if c == '\n': S += '\\n'
            elif c == '\t': S += '\\t'
            else: S += c
        return S + '\''

## number
class Number(Primitive):
    ## construct with `float:value`
    def __init__(self,V,token=None):
        Primitive.__init__(self, V, token)
        ## convert with `float()`
        self.value = float(V)

## integer
class Integer(Number):
    ## construct with `int:value`
    def __init__(self,V,token=None):
        Primitive.__init__(self, V, token)
        ## convert with `int()`
        self.value = int(V)

## machine hex
class Hex(Integer):
    ## override with `int(base=16)`
    def __init__(self,V,token=None):
        Primitive.__init__(self, V, token)
        ## convert with `base=16`
        self.value = int(V[2:],0x10)
    ## hex number print
    ## @returns string value in `0x[0-9A-F]+` form
    def str(self): return '0x%X' % self.value

## machine binary
class Binary(Integer):
    ## override with `int(base=2)`
    def __init__(self,V,token=None):
        Primitive.__init__(self, V, token)
        ## convert with `base=2`
        self.value = int(V[2:],0x02)
    ## binary number print
    ## @returns string value in `0b[01]+` form
    def str(self): return '0b{0:b}'.format(self.value)

## @}


## @defgroup container Container
## @brief Objects targeted for data holding: can contain nested data elements
## @{

## data container
class Container(Qbject):
    ## drop all elements
    def dropall(self): del self.nest[:]

## LIFO stack
class Stack(Container): pass

## ordered vector (list)
class Vector(Container): pass

## associative array (vocabulary)
class Map(Container):
    ## `<<` operator
    def __lshift__(self,o):
        self.attr[o.__name__] = VM(o)
        return self
    ## @return keys
    def keys(self): return self.attr.keys()

## @}


## @defgroup active Active
## @brief Objects has executable semantics
## @{
 
## Objects has executable semantics
class Active(Qbject): pass

## function
class Function(Active):
    ## wraps Python function
    ## @param[in] F function will be wrapped
    ## @param[in] immed immediate function will be executed in COMPILE mode
    ## @param[in] doc docstring
    def __init__(self, F, immed=False, doc=''):
        Active.__init__(self, F.__name__, doc=doc)
        ## wrap function
        self.fn = F
        ## immediate flag
        self.immed = immed
    ## implement callable via wrapped function call
    def __call__(self): return self.fn()

## Virtual Machine command
class VM(Function): pass

## colon definition (executable vector)
class ColonDef(Active):
    ## @warning inherited via `__init__` from `Vector` (mixin alike)
    ## @param[in] V definition FORTH word name 
    ## @param[in] immed immediate flag can be set @see Function
    def __init__(self, V, immed=False):
        Active.__init__(self,V)
        ## override `immed` flag
        self.immed = immed
    ## @todo execute colondef
    def __call__(self): raise BaseException(self)

## @}


## @defgroup meta Meta
## @brief Metaprogramming types and objects
## @{
         
## metaprogramming
class Meta(Qbject): pass

## comment
class Comment(Meta,String):
    ## dump head in linear string format
    def str(self): return String.str(self)

## operator
class Operator(Meta): pass

## definition operator (compiler words)
## shuld have different colorizing in editor
class DefOperator(Operator): pass

## @}


## @defgroup io IO
## @brief Filesystem and Network interfacing 
## @{

## @}


## @}


## @defgroup fvm oFORTH Virtual Machine
## @brief FORTH-inspired stack engine based on OOP /no addressable memory/
## @{

## data stack
D = Stack('DATA')

## @defgroup voc Vocabulary
## @{

## vocabulary
W = Map('FORTH')

## @defgroup persist persistent storage
## @brief store system state in `.image` file
## @{ 
 
import pickle
 
## image file name
IMAGE = sys.argv[0] + '.image'
W['IMAGE'] = String(IMAGE)

## backup vocabulary to `.image`
def BACKUP():
    # filter vocabulary ignoring all functions (VM commands) 
    B = {}
    for i in W.keys():
        if W[i].type not in ['vm','function']: B[i] = W[i]
    F = open(IMAGE,'wb') ; pickle.dump(B,F) ; F.close()
W << BACKUP

## restore from vocabulary  `.image`
def RESTORE():
    global W
    try: F = open(IMAGE,'rb') ; B = pickle.load(F) ; F.close()
    except IOError: B = {}
    # override all elements from loaded image
    for i in B: W[i] = B[i]
W << RESTORE

## @}
## @}

## @defgroup s1lexer Syntax parser
## @brief powered with
## <a href="http://ponyatov.quora.com/Text-data-formats-Parsing-with-Python-and-PLY-library">PLY library</a>
## `(c) David M Beazley` 
## @{

import ply.lex  as lex
import ply.yacc as yacc

## @}

## @}

## @defgroup metainfo Metainformation
## @brief Project info
## @{

## short module name
MODULE  = 'proto'
## short info about module (oneliner)
TITLE   = 'prototype knowledge database implementation'
## contact emain
EMAIL   = 'dponyatov@gmail.com'
## author
AUTHOR  = 'Dmitry Ponyatov'
## licence info
LICENCE = 'All rights reserved'
## github repository location
GITHUB  = 'https://github.com/ponyatov/proto'
## manual
MANUAL  = 'Quora blog: http://www.quora.com/profile/Dmitry-Ponyatov/all_posts'
## license
LICENSE = 'All rights reserved'
 
## longer project about
ABOUT  = '''
'''

## autogenerated README.md
README = '''
# %s
## %s
### <a href="http://ponyatov.quora.com/">Follow my blog</a> on Quora about it
 
(c) %s <<%s>>, %s

%s
 
github: %s
 
%s
''' % (MODULE, TITLE, AUTHOR, EMAIL, LICENSE, ABOUT, GITHUB, ABOUT)

W['MODULE']  = String(MODULE)
W['TITLE']   = String(TITLE)
W['ABOUT']   = String(ABOUT)
W['AUTHOR']  = String(AUTHOR)
W['LICENCE'] = String(LICENCE)
W['GITHUB']  = String(GITHUB)
W['MANUAL']  = String(MANUAL)
W['README']  = String(README)

W['STAGE']   = Number(re.findall(r'S(\d)\.py$',sys.argv[0])[0])

## @}

## @}


print W
